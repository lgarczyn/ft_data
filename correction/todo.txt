todo:
    find way to chck for forbidden functions
    add instructions for profiler use
    test malloc failure
    update subject for correction
    remove diff thing

instructions
	check norme
    check optimisation level
	check allowed functions
		xmalloc
		xfree
        any call to functiosn defined in mem, especially modify_mem_score, is -42
		You can use more, but remember that this is supposed to be used in projects
	check MAGIC numbers
	check main.c after diff
    check valgrind if you want, but the user can defend himself
        basically is he erasing sensitive data or not
    check crash
        if a crash is due to incorrect use, it's ok
        the main is strictly correct used
    prints are allowed under incorrect use
        
    
advice
    check state at start
    use debugger
    init memory to 0
    reimplement realloc
        (can offer some cheap perf if authorized)

bonus implementation
    array
    bitset
    sorted
    pmait
    pmait 2
    pmait 3

bonus performance
    good perf mem
        total vs max total
        for every functions ?
        prevent min-maxxing
    good perf cpu
        vs standard on school computer
        not much to do

bonus suggestions
    a switch allowing pma or sorted to have duplicate elements
    some way to templatize all that using makefile MAGIC
    1 point per 5 small functions, or 3 larger functions
    possibility to use realloc if allowed

mandatory header parts
    prototypes
    t_sortedres/t_sorteden/t_sorteden
    t_pmaen
    t_uint
    t_array
        bzeroed must be valid
        must contain a data element ?

/*
** Functions returning an int return OK on success but may return an error,
** ERR_ALLOC if it failed to allocate new memory
** ERR_SIZE if it would need to access an element out of bounds
** ERR_MISSING if a search function fails to find the key
** A function that returned an error value must not modify the structure in any way
*/

/*
** Array Basic API
**
** array          Return a valid empty array. Don't allocate any memory.
** array_free     Free array, and reset it to an empty state
** array_len      Return length of the used part of the array
** array_reserve  Increase available memory, doesn't affect length
** array_push     Add "size" bytes from "data" to end of array
** array_pop      Remove "size" bytes from end of array to "data"
*/

t_array		array(void);
void		array_free(t_array *a);
size_t		array_len(const t_array *a);
int			array_reserve(t_array *a, size_t size);
int			array_push(t_array *a, const void *data, size_t size);
int			array_pop(t_array *a, void *data, size_t size);

/*
** Array Bonus API
**
** array_set_len  Change used length of array to "size". Zeros new bytes.
** array_insert   Insert "size" bytes from "data" at position "i"
**                  Make room by moving data to the right
** array_remove   Remove "size" bytes from position "i" to "data"
**                  Fill room by moving data to the left
*/

int			array_set_len(t_array *a, size_t len);
int			array_insert(t_array *a, const void *data, size_t i, size_t size);
int			array_remove(t_array *a, void *data, size_t i, size_t size);

/*
** Bitset Basic API
** 
** bitset           Return a valid empty bitset. Don't allocate any memory.
** bitset_free      Free bitset, and reset it to an empty state
** bitset_len       Return number of bits in the used part of the bitset
** bitset_set_len   Change number of available bits to "size". Zeros new bits.
** bitset_get       Return the bit at position "i"
** bitset_set       Set the bit at position "i" to "b"
** bitset_display   Display the bitset like:
**                    9: [X__XXXX__]
*/

t_bitset	bitset(void);
void		bitset_free(t_bitset *a);
size_t		bitset_len(const t_bitset *a);
int			bitset_set_len(t_bitset *bitset, size_t len);
bool		bitset_get(const t_bitset *a, size_t i);
void		bitset_set(t_bitset *a, size_t i, bool b);
void        bitset_display(const t_bitset *a);

/*
** Bitset Bonus Api
**
** bitset_reserve       Increase available memory, doesn't affect length
** bitset_get_safe      Set "b" to the value of the bit at position "i"
** bitset_set_safe      Set the bit at position "i" to the value of "b" 
** bitset_push          Add "b" to the end of the bitset
** bitset_pop           Removes the last bit and store it in "b"
*/

int			bitset_reserve(t_bitset *bitset, size_t new_size);
int			bitset_get_safe(const t_bitset *a, size_t i, bool *out);
int			bitset_set_safe(t_bitset *a, size_t i, bool b);
int			bitset_push(t_bitset *a, bool b);
int			bitset_pop(t_bitset *a, bool *b);

/*
** Queue Basic Api
**
** queue                Return an empty queue, with elements of size "word"
** queue_free           Free queue, and reset it to an empty state
** queue_len            Return number of elements in the queue
** queue_reserve        Increase available memory to "size"
** queue_push_back      Add "data" to back of the queue
** queue_push_front     Add "data" to front of the queue
** queue_pop_back       Remove the last element, and store in "data"
** queue_pop_front      Remove the first element, and store in "data"
*/

t_queue		queue(t_uint word);
void		queue_free(t_queue *a);
size_t		queue_len(const t_queue *a);
int			queue_reserve(t_queue *a, size_t s);
int			queue_push_back(t_queue *a, const void *data);
int			queue_push_front(t_queue *a, const void *data);
int			queue_pop_back(t_queue *a, void *data);
int			queue_pop_front(t_queue *a, void *data);

/*
** Sorted Basic Api
**
** sorted
** sorted_free
** sorted_len
** sorted_reserve
** sorted_get
** sorted_search
** sorted_insert
** sorted_delete
*/

t_sorted	sorted(t_predicate predicate, t_uint word);
void		sorted_free(t_sorted *a);
size_t		sorted_len(const t_sorted *a);
int			sorted_reserve(t_sorted *a, size_t s);
const void  *sorted_get(t_sorted *a, size_t index);
t_sorteden	sorted_search(const t_sorted *a, const void *d);
int			sorted_insert(t_sorted *a, const void *data);
t_sorteden	sorted_delete(t_sorted *a, const void *data, void *out);

/*
** Sorted Bonus Api
**

*/

int			sorted_pop(t_sorted *a, void *data);
int			sorted_insert_hint(t_sorted *a, const void *d, size_t h);
void		sorted_delete_index(t_sorted *a, size_t index, void *out);

/*
** Packed Memory Array Basic Api
**

*/

t_pma		pma(t_predicate predicate, t_uint key, t_uint value);
void		pma_free(t_pma *a);
size_t		pma_len(const t_pma *a);
int			pma_insert(t_pma *a, const void *key, const void *val);
int			pma_delete(t_pma *a, const void *key, void *o_key, void *o_val);
int			pma_get(const t_pma *a, const void *key, void *o_key, void *o_val);
//9: [X__XXXX__]
//5: {0:32664 1:32650 5:32714 6:32545 7:32765}
void		pma_display(t_pma *a, t_printer print_key, t_printer print_char);
int			pma_pop_back(t_pma *a, void *key, void *val);
int			pma_pop_front(t_pma *a, void *key, void *val);

/*
** Packed Memory Array Bonus Api
**

*/

t_pmaen		pma_search(const t_pma *a, const void *key);
t_pmait		pmait(const t_pma *a);
bool		pmait_next(t_pmait *i, void *key, void *val);
bool		pmait_delete(t_pmait *i, void *key, void *val);
//       >----<
//9: [X__XXXX__]
//5: {0:32664 1:32650 5:32714 6:32545 7:32765}
void		pmait_display(t_pmait *it, t_printer print_key, t_printer print_char);

/*
** Packed Memory Array Bonus Api
**

*/

t_pmait		pma_range(const t_pma *a, void *key_a, void *key_b);
bool		pmait_next_back(t_pmait *i, void *key, void *val);
bool		pmait_delete_back(t_pmait *i, void *key, void *val);
